# C++基础

## gdb的使用

使用如下代码编译.cpp文件，可以使用调试符号编译代码，使其能够适用于GDB调试

```shell
g++ -g program.cpp -o program
```

上述代码会生成可调试的可执行文件，使用如下指令进行调试

```shell
gdb program
# 必须使用gdb命令进行调试，此处列出常用gdb命令
# b line_number :在指定行创建断点
# n :运行下一行代码
# r :运行到断点处
# p variable_name :打印变量值
# q :退出调试器
```

## 类和结构体的区别

结构体只能定义不同的成员变量，但是类不仅可以定义成员变量还可以声明不同的成员函数，为了保证类定义的简洁性常在类中声明然后在类的外部进行定义。

## 类访问修饰符

public:一个公有成员可以从类之外的任何地方被访问。人们可以直接访问公共变量，不需要编写其他辅助函数

private:不能从类外部被查看或访问，只有类和友元函数可以访问私有成员，子类不可访问

protected:访问类似于private成员，但是其子类可以访问其成员

## 继承

父类$\rightarrow$子类$\Leftrightarrow$基类$\rightarrow$派生类

三种继承类型：

- public inheritance:派生自public基类，基类的public成员成为派生类的public成员，基类的protected成员成为派生类的protected成员，无法访问基类的private成员，但是可以通过对基类的public和protected成员函数调用访问private成员
- private inheritance:派生自private基类，基类的public和protected成员成为派生类的private成员
- protected inheritance:派生自protected基类，基类的public和protected成员成为派生类的protected成员

继承的示例

```c++
class child_class: public parent_class    //public inheritence
class child_class: private parent_class   //private inheritence
class child_class: protected parent_class //protected inheritence  
```

## 文件和流

标准C++库-fstream

三种数据类型

1. ofstream--输出文件流，可创建文件并写入数据
2. ifstream--输入文件流，可从文件中读取数据
3. fstream--读/写文件流

示例

```c++
#include <fstream>
#include <iostream>
#include <string>
using namespace std;
int main(){
  ofstream out_file;//定义输出文件流对象
  string data = "output data"
  out_file.open("output.txt");//打开输出文件
  out_file << data << endl;//将数据写入输出文件
  out_file.close();//关闭文件
  ifstream in_file;//定义输入文件流对象
  in_file.open("output.txt");//打开输入文件
  in_file >> "changed" >> data;//从文件中读取数据输入
  cout << data << endl;
  in_file.close();//关闭文件
  return 0;
}
```

## 命名空间的定义

```c++
using namespace space1{
  void process(void){
    //...
  }
}
using namespace space2{
  void process(void){
    //...
  }
}
int main(){
  space1::process();
  space2::process();
}
```

## 异常处理

异常通常出现在运行阶段，主要用3个关键词处理异常

- try:在try的测试块中编写可能引发异常的代码
- catch:try中的测试块若出现了异常，则catch后面的代码会捕捉异常
- throw:开始出现问题时，可以从try的测试块中抛出异常，该异常可以被后边的catch块捕捉到

示例如下

```c++
try{
  //自己的代码
  if(situation==true){
    throw Exception name;
  }
}
catch(Exception name){
  //异常处理
}
```

## C++工程组织

多个C++源文件不易编译，可以使用Makefile以及Cmake工具辅助编译。Cmake会解析制定目录中的CMakeLists.txt文件生成Makefile文件，将写Makefile文件的过程自动化了。

# Python基础

python是一种动态语言，它把每个变量看作一个对象，这意味着我们不必在编程中提供变量的数据类型。C++就是一种静态语言，每个变量必须制定一个数据类型，变量也只能赋予对应类型的数据。

python中没有数组的概念，但是python提供了列表(Lists)、元组(Tuples)以及内嵌的字典(Dictionary)数据类型，三种类型示例如下

```python
number_list = [1,2,3,4,5]
number_list[0]
number_tuple = ("one","two","three")
number_tuple[0]
number_dict = {"one":1, "two":2}
number_dict["one"]
```

列表使用[]包含数据，元组使用()包含数据，另外元组是只读的，初始化后不可更改，列表可以修改。

字典中指定了键(Key)和与之关联的值(Value)，在字典中给出键会返回对应的值

## 用户输入

```python
input()#只接受整数数据
raw_input()#接受任意类型数据
```

## 异常处理

```python
try:
  #自己的代码
except:
  #异常处理代码
```

## 类

python中使用如下方法定义类，定义类时总是先给出构造函数\__init__，类中所有的函数第一个参数都应该是self，它表示该函数被当前类所拥有，还可以通过它访问类中的其他成员

```python
class demo_class:
  def __init__(self):
    #函数体
  def demo_func(self):
    #函数体
  def __del__(self):
    #函数体
```

上面定义的\__del__函数称为析构函数，当对象被销毁时调用，析构函数不同于构造函数，可以不进行定义

## 文件

python通过open、write、readline函数打开并读写文件，具体示例如下

```python
file = open("demo.txt","w+")#第二个参数给出打开模式，w+表示写入，r表示只读
file.write("enter")
file.close()#关闭文件
file=open("demo.txt","r")
print file.readline()#读取一行
```

## 模块

类似于C++中的头文件，模块中可以包含类、函数和变量，使用import命令导入

## 串行端口

使用PySerial模块于串行端口通信

通过如下指令安装

```shell
sudo apt-get install python-serial
```

使用如下指令查看电脑连接的串口设备

```shell
dmesg
```

调用此模块代码如下

```python
import serial
ser = serial.Serial('/dev/ttyUSB0',9600)
ser.write('Hello')#串口写入
text = ser.readline()#串口读数据
text = ser.read()#读取一个字节
text = ser.read(10)#读取十个字节
```

# ROS概述

## 机器人编程的特性

1. 线程化--兼容多线程实现在不同的线程中使用不同的传感器和作动器，即完成多任务。
2. OOP
3. 底层设备控制
4. 编程简便
5. 进程间通信--实现多传感器和作动器之间的相互通信
6. 性能
7. 社区支持
8. 第三方库
9. 现有框架支持

## ROS命令行工具

roscore

## ROS图形用户接口

### Rviz

Rviz能将图像数据、3D点云、机器人模型和坐标变换数据等可视化

```shell
roscore
rosrun rviz rviz
```

### Rqt

Rqt可将2D数据可视化、将话题记入日志、发布话题和请求服务

```shell
roscore
rosrun rqt_gui rqt_gui
```

# ROS编程

## 创建ROS工作空间和程序包

在目标文件夹下创建src文件夹，进入src文件夹后使用如下命令初始化工作空间

```shell
catkin_init_workspace
```

上述命令会在src文件夹下生成一个CMakeLists.txt文件，然后我们退至目标文件夹使用如下命令生成工作空间

```shell
catkin_make
```

在工作空间下会生成build和devel两个文件夹，程序包存储在src中，在执行catkin_make命令后，catkin会检查src文件夹中的程序包并一一编译，生成的中间编译文件和缓存文件会存放在build文件夹下，编译成功后创建的目标可执行文件会放在devel文件夹中。

然后我们需要将工作空间加入环境变量，否则无法调用程序包

在~/.bashrc文件末尾加入以下命令

```shell
source ~/${workspace}/devel/setup.bash
```

在catkin成功编译生成目标可执行文件后，在工作空间文件夹中执行以下命令来安装可执行文件

```shell
catkin_make install
```

会生成一个名为install的文件夹，其中存放的就是安装的目标文件，运行程序时，install文件夹中相应的可执行文件会被执行。

## ROS程序包

使用如下命令创建程序包

```shell
catkin_create_pkg ${package_name} ${package_dependencies}
```

## ROS客户端库

官方提供的有如下客户端库：

> roscpp,rospy,roslist,rosjava,rosnodejs,roslua

